---
title: "Parkinson's telemonitoring"
author: "Rushan Shakya, Tahrima Mustafa, Cam Moy, Praveen Hariharasubramanian"
date: "April 21, 2018"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction
Goal of this project is to identify most significant measures that can help in measuring progression of parkinson's disease so that measurements from devices can be used to diagnose and treat a patient without personal physician diagnosis requirements.

##Code and interpretation
```{r}
#Read the data file
#parkinsons <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/parkinsons/telemonitoring/parkinsons_updrs.data", header = TRUE)
parkinsons <- read.csv("C:\\Users\\Praveen\\Documents\\MSDS\\ISQS6350-multivariateanalysis\\project\\parkinsons_updrs.csv", header = TRUE, stringsAsFactors = TRUE)
str(parkinsons)
```
#Check null values
```{r}
missing <- apply(parkinsons, 2, function(x) 
  round(100 * (length(which(is.na(x))))/length(x) , digits = 1))
as.data.frame(missing)
```
There are no missing values in our dataset.

#Check correlations between the variables
```{r}
library(corrplot)
corrplot(cor(parkinsons), type="full", method ="color", title = "Parkinson correlatoin plot", mar=c(0,0,1,0), tl.cex= 0.8, outline= T, tl.col="indianred4")
```
We can see that all the jitter variables highly correlate with Shimmer variables.

#Outlier detection
```{r}
summary(parkinsons[,-3])
```

The total_UPDRS (Unified Parkinson's Disease Ratings Score) is the main variable of interest, which determines the clinical impression of Parkinson's disease (PD) severity. Thus, we plot total_UPDRS scores against other variables in our data set to find out outliers.

```{r}
#Scattered plot to look into data distribution
plot(jitter(total_UPDRS)~., parkinsons)
```

In our scattered plot between total_UPDRS and Jitter, it looks like, we can see out outlier observations in our data. Similarly, in our plots with total_UPDRS vs Shimmer, total_UPDRS vs NHR, total_UPDRS vs RPDE, total_UPDRS vs DFA, and total_UPDRS vs PPE, we can see some outlier observations.

We will now look into bivariate boxplots in our data to look for outlier observations in our data.
```{r}
library(MVA)
#boxplots
bvbox(parkinsons[,6:7], xlab = "total_UPDRS", ylab = "Jitter")

bvbox(parkinsons[,c(6,12)], xlab = "total_UPDRS", ylab = "Shimmer")

bvbox(parkinsons[,c(6,18)], xlab = "total_UPDRS", ylab = "NHR")

bvbox(parkinsons[,c(6,20)], xlab = "total_UPDRS", ylab = "RPDE")

bvbox(parkinsons[,c(6,21)], xlab = "total_UPDRS", ylab = "DFA")

bvbox(parkinsons[,c(6,22)], xlab = "total_UPDRS", ylab = "PPE")
```
The bivariate boxplot is showing a lot of our observations as outliers. Thus, we want to check our results with Convex Hull method as we don't want to change the distribution of our data by removing the outliers.

```{r}
#Convex hull method

hull1 <- chull(parkinsons[,6:7])

parkhull <- match(lab <- rownames(parkinsons[hull1,])
, rownames(parkinsons))

plot(parkinsons[,6:7], xlab = "total_UPDRS", ylab = "Jitter")
polygon(parkinsons$Jitter...[hull1]~parkinsons$total_UPDRS[hull1])
text(parkinsons[parkhull,6:7], labels = lab
, pch=".", cex = 0.9)
```

```{r}
#Removing outlier observations according to Convex hull
outlier <- parkinsons[-hull1,]
dim(outlier)
dim(parkinsons)

hull2 <- chull(outlier[,c(6,12)])
parkinsons <- outlier[-hull2,]

hull3 <- chull(parkinsons[,c(6,18)])
outlier <- parkinsons[-hull3,]

hull4 <- chull(parkinsons[,c(6,20)])
parkinsons <- outlier[-hull4,]

hull5 <- chull(parkinsons[,c(6,21)])
outlier <- parkinsons[-hull5,]

hull6 <- chull(parkinsons[,c(6,22)])
parkinsons <- outlier[-hull6,]

dim(parkinsons)
```

Principal Componenets Analysis

```{r}
#PCA
library(stats)
#outliers have alreaady been removed so PCA does not requiere any changes in the data
#standard deviations of data set
p_sd <- sd(is.numeric(parkinsons))
# creating covariance matrix for entire dataset
p_cov <- cov(parkinsons, use = "everything")
#creating correlation matrix for the entire dataset
p_corr <-cor(parkinsons, use = "everything")

#Principal Components Analysis for correlation matrix
# we have chosen to utilize the correlation matrix for the PCA since the variables have different scales and variances
parkinsons_pca_corr <- princomp(covmat = p_corr)
summary(parkinsons_pca_corr, loadings = T)


```

#covariance matrix interpretation

All of the variables showcase small magnitudes which can have positive or negative linear releationships.
 
#correlation matrix interpretation

From the correlation matrix we have observatins:

* Variable HNR which is the ratio of noise to tonal components in the voice. This variable has an inverse releationship with all the variables.

* Variables containing the word "Shimmer" have high positive correlation values with each other.

* Variables containing the word "Jitter" have high positive correlation values with each other

* High correlation values between variables containing the word Shimer with variables containing the word "Jitter"

* The PPE variable represents a nonlinear measure of fundamental frequency variation. This variable has strong positive correlations with varaibles containing the word "jitters" or "Shimmers" and the variable RPDE. RPDE represents a nonlinear dynamical complexity measure.

* "total_UPDRS" and "motor_UPDRS" showcase a strong positive correlation. Where, "total_UPDRS" represents clinician's total UPDRS score  and "motor_UPDRS"  the clinician's motor UPDRS score both, linearly interpolated. 

 
# PCA interpretation
 
* The amount of components was determined according to the following rule. The total amount of variation that the components represent must be within 70% to 90%.

*According to this parameter components 1 through 4 where selected. These components amount to a total of 76% of the total variation.

#Multi dimensional scaling

```{r}
parkcorr <- cor(parkinsons)
colnames(parkcorr) <- row.names(parkcorr) <- parklabs <- c(colnames(parkinsons))
rge <- sapply(parkinsons, function(x) diff(range(x)))
sparkinsons <- sweep(parkinsons, 2, rge, FUN = "/")
parkdist <- dist(sparkinsons)
parkdist_mds <- cmdscale(parkdist, k = 21, eig = TRUE)
parkdistpoints <- parkdist_mds$points
lam <- parkdist_mds$eig
criterion1 <- cumsum(abs(lam)) / sum(abs(lam))
criterion2 <- cumsum(lam^2) / sum(lam^2)
#criterion 2 suggests that the first two coordinates are required to represent majority of the data points since the cummulative proportion is 0.78 and close to the threshold value of 0.8 
#hence the MDS plot can be on a 2D scatterplot
x <- parkdist_mds$points[,1]
y <- parkdist_mds$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2", main="Parkinsons MDS",pch=20,cex=0.1)
text(x, y, labels = parkinsons[,3], cex=0.8)
#the MDS plot clearly shows that age is creating a deviation between the datasets with female on the right and male on the left
#this significant deviation is because the voice pictch, frequency and amplitude totally differs by being in different ranges for different genders
```

```{r}
parkcorr <- cor(parkinsons)
colnames(parkcorr) <- row.names(parkcorr) <- parklabs <- c(colnames(parkinsons))
rge <- sapply(parkinsons, function(x) diff(range(x)))
sparkinsons <- sweep(parkinsons, 2, rge, FUN = "/")
parkdist <- dist(parkcorr)
parkdist_mds <- cmdscale(parkdist, k = 21, eig = TRUE)
parkdistpoints <- parkdist_mds$points
lam <- parkdist_mds$eig
criterion1 <- cumsum(abs(lam)) / sum(abs(lam))
criterion2 <- cumsum(lam^2) / sum(lam^2)
#criterion 1 and criterion 2 suggests that the first two coordinates can represents majority of the data points since the cummulative proportion is above the threshold value of 0.8 
#hence the MDS plot can be on a 2D scatterplot
x <- parkdist_mds$points[,1]
y <- parkdist_mds$points[,2]
plot(x, y, xlab="Coordinate 1", ylab="Coordinate 2", main="Parkinsons MDS",pch=20,cex=0.1)
text(x, y, labels = colnames(parkcorr), cex=0.8)
```

The statitical technique of multi dimensional scaling through this plot has confirmed that attributes form groups with similar patterns
1. All jitter variables follow a pattern
2. All Shimmer variables follow a patter
3. PPE and NHR form a pattern
4. total UPDRS and motor UPDRS form a pattern
5. test time and sex form a pattern
6. Age contributes as a seperate attribute to the variation in data
7. HNR contributes as a seperate attribute to the variation in data

These findings can be logically understood as
1. Jitter is related to frequency measure so they form a pattern and it is logically valid
2. Shimmer is related to amplitude measure so they form a pattern and it is logically valid
3. Pitch of voice cord and noise to harmonics ratio are having an underlying relationship and that is observable through this finding
4. Motor UPDRS score is impacting the total score and it makes sense
5. Test time and sex are two independent factors and they are showing correlation by coincidence and this inference can be ignored
6. Age contributes as a seperate attribute to the variation in data
7. HNR contributes as a seperate attribute to the variation in data

To confirm that the observations in the multi dimensional scaling can be used to better identify patients with disease and ideal measures to estimate progression of the disease and interpret the similarity between cetain measures let us apply another technique called random forests algorithm that uses gini index which is another way of measuring dissimilarity in the data like multi dimensional scaling.

Random forest helps in measuring and identifying the correct measure that can aid in differentiating the data and better differentiate patients and ranking the different variables by there contribution to the variance of the dataset and also on their significance in measuring progression of the disease.

```{r}
library(randomForest)
#scaling the data
rge <- sapply(parkinsons, function(x) diff(range(x)))
sparkinsons <- sweep(parkinsons, 2, rge, FUN = "/")
# Create the forest.
output.forest <- randomForest(sparkinsons$total_UPDRS~age+sex+test_time+Jitter...+Jitter.Abs.+Jitter.RAP+Jitter.PPQ5+Jitter.DDP+Shimmer+Shimmer.dB.+Shimmer.APQ3+Shimmer.APQ5+Shimmer.APQ11+Shimmer.DDA+NHR+HNR+RPDE+DFA+PPE, data = sparkinsons,mtry = 6)

# View the forest results.
print(output.forest) 

# Importance of each predictor.
impfactors <- importance(output.forest,type = 2)
impfactors <- data.frame(impfactors)
impfactorsranked <- impfactors[order(-impfactors$IncNodePurity),,drop=FALSE]
print(impfactorsranked)
#On applying random forest we can observe that certain attributes contribute higher to the split in the dataset i.e. certain observations help better in categorising patients based on UPDRS scores and contribute higher to disease progression or severity
#motor UPDRS ignored since its a subset of total UPDRS
#subject id ignored since its the id of each patient
#These attributes are
#Age - Subject age
#Sex - Subject gender '0' - male, '1' - female
#test_time - Time since recruitment into the trial. The integer part is the number of days since recruitment.
#HNR - Harmonics to noise ratio (HNR) quantify the ratio of actual signal information over noise
#RPDE - Recurrence Period Density Entropy (RPDE) Quantify the stochastic component of the deviation of vocal fold periodicity. Vocal fold periodicity is the periodicity/frequency of vibration of the vocal cord
#DFA - Detrended Fluctuation Analysis (DFA) Quantify the stochastic self-similarity of the noise caused by turbulent airflow
#PPE - Pitch Period Entropy (PPE). In speech disorders it is very difficult to sustain stable pitch due to incomplete vocal fold closure. PPE quantifies the impaired control of stabilized pitch
#Jitter(Abs) - Jitter absolute is the average absolute difference between consecutive periods, divided by the average period in fundamental frequency
```

Random forest has helped in indentifying the top factors that influence the disease progression and that are DFA, Age, JItter.Abs.,Sex, PPE, HNR, RPDE and test_time.

Age - Subject age

Sex - Subject gender '0' - male, '1' - female

test_time - Time since recruitment into the trial. The integer part is the number of days since recruitment.

Jitter (%) - Mean absolute difference of successive cycles divided by the mean of Fundamental frequency (expressed in percentage)

HNR - Harmonics to noise ratio (HNR) quantify the ratio of actual signal information over noise

RPDE - Recurrence Period Density Entropy (RPDE) Quantify the stochastic component of the deviation of vocal fold periodicity. Vocal fold periodicity is the periodicity/frequency of vibration of the vocal cord

DFA - Detrended Fluctuation Analysis (DFA) Quantify the stochastic self-similarity of the noise caused by turbulent airflow

PPE - Pitch Period Entropy (PPE). In speech disorders it is very difficult to sustain stable pitch due to incomplete vocal fold closure. PPE quantifies the impaired control of stabilized pitch

#Exploratory factor analysis
```{r}
library(MVA)
options(digits = 3)
# EFA
head(parkinsons) #2:4,8,16,18:22
parkinson.EFA <- factanal(parkinsons[, c(2:8,17,18:22)], 5, n.obs = nrow(parkinsons), rotation="varimax", control=list(trace=T))
parkinson.EFA
print(parkinson.EFA$loadings, cut = 0.5)
```

First, when we try to do exploratory factor analysis with all the variables, the model doesn't run. After some research we have come to the conclusion that due to high multicolinearity between some variables, the algorithm is not converging. So we decided to reduce the values that have high correlation between them. From the correlation plot we can see that jitter and shimmer variables have high correlation (0.9+) between themselves. So we tried building the model with one jitter and one shimmer variable. From the random forest analysis, we saw that Jitter.Abs. and Shimmer.APQ11 have highest significance in their corresponding frequency and amplitude groups. So we took these 2 variables in the exploratory factor analysis. Also both the updrs variables have 0.9+ correlation between them. So we took one from that group too.

With the above mentioned variables we explored different number of factors. But if we take 2 or 3 factors then only 40-45% data is explained. Also the age, sex and test_time have very small factor coefficient and large (0.85+) uniqueness. If we have 5/6 factors then the uniqueness of these variables lessen but still they are greater than 0.7.

```{r}
parkinson.EFA <- factanal(parkinsons[, c(2:8,17,18:22)], 2, n.obs = nrow(parkinsons), rotation="varimax", control=list(trace=T))
parkinson.EFA
print(parkinson.EFA$loadings, cut = 0.5)

#Implementing Confirmatory actor analysis from the observed factors in the exploratory factor analysis

library(sem)
library(semPlot)
parkinsonscov<- cor(parkinsons[,-c(1)])
parkinson_model <- specifyModel(file = "C:\\Users\\Praveen\\Documents\\MSDS\\ISQS6350-multivariateanalysis\\project\\parkinson_sem_model_efa2.txt")
opt <- options(fit.indices = c("GFI", "AGFI", "SRMR"))
parkinson_sem <- sem(parkinson_model, parkinsonscov, nrow(parkinsons))
summary(parkinson_sem)
# restricted Cor matrix
rescor <- parkinson_sem$C
# non-restricted Cor matrix
nonrescor <- parkinson_sem$S

#differences of the elements of the observed covariance matrix and the covariance matrix of the fitted model
covresiduals <- round(parkinson_sem$S - parkinson_sem$C, 3)

semPaths(parkinson_sem, "est",edge.label.cex=1.5)

```

```{r}
library(sem)
library(semPlot)
parkinsonscov<- cor(parkinsons[,-c(1)])
parkinson_model <- specifyModel(file = "C:\\Users\\Praveen\\Documents\\MSDS\\ISQS6350-multivariateanalysis\\project\\parkinson_sem_model_efa1.txt")
opt <- options(fit.indices = c("GFI", "AGFI", "SRMR"))
parkinson_sem <- sem(parkinson_model, parkinsonscov, nrow(parkinsons))
summary(parkinson_sem)
# restricted Cor matrix
rescor <- parkinson_sem$C
# non-restricted Cor matrix
nonrescor <- parkinson_sem$S

#differences of the elements of the observed covariance matrix and the covariance matrix of the fitted model
covresiduals <- round(parkinson_sem$S - parkinson_sem$C, 3)

semPaths(parkinson_sem, "est",edge.label.cex=1.5)
```

